!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("three")):"function"==typeof define&&define.amd?define("prettyGraphCore",["three"],e):"object"==typeof exports?exports.prettyGraphCore=e(require("three")):t.prettyGraphCore=e(t.three)}("undefined"!=typeof self?self:this,function(t){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=1)}([function(e,n){e.exports=t},function(t,e,n){"use strict";n.r(e);var i=n(0);class s{constructor(){this.events={}}on(t,e){return"object"!=typeof this.events[t]&&(this.events[t]=[]),this.events[t].push(e),()=>this.removeListener(t,e)}removeListener(t,e){if("object"!=typeof this.events[t])return;const n=this.events[t].indexOf(e);n>-1&&this.events[t].splice(n,1)}removeAllListeners(){Object.keys(this.events).forEach(t=>this.events[t].splice(0,this.events[t].length))}emit(t,...e){"object"==typeof this.events[t]&&[...this.events[t]].forEach(t=>t.apply(this,e))}once(t,e){const n=this.on(t,(...t)=>{n(),e.apply(this,t)});return n}}const r="\n  precision mediump float;\n\n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float scale;\n  uniform vec2 spriteDim;\n  uniform vec2 textureDim;\n\n  attribute vec3 position;    // blueprint's vertex positions\n  attribute vec3 color;       // only used for raycasting\n  attribute vec3 translation; // x y translation offsets for an instance\n  attribute float size;\n  attribute float image;\n\n  varying vec3 vColor;\n  varying float vScale;\n  varying highp vec4 v_sprite;\n\n  void main() {\n    vColor = color;\n    vScale = scale;\n\n    highp vec2 sp = vec2(mod((image * spriteDim.x), textureDim.x), floor((image * spriteDim.x) / textureDim.y) * spriteDim.y);\n    v_sprite = vec4(sp.x / textureDim.x, sp.y / textureDim.y, spriteDim.x / textureDim.x, spriteDim.y / textureDim.y);\n\n    vec3 pos = position + translation;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n\n    gl_PointSize = size * scale * 10.0;\n  }\n",o="\n  #ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n  #endif\n\n  precision highp float;\n\n  uniform sampler2D textureMap;\n  uniform float useColor;\n\n  varying float vScale;\n  varying vec3 vColor;\n  varying highp vec4 v_sprite;\n\n  void main() {\n    vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\n    float distance = 0.2;\n    float border = 0.2;\n    float radius = 0.5;\n\n    if (useColor == 1.) {\n      float r = 0.0, delta = 0.0, alpha = 1.0;\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      r = dot(cxy, cxy);\n      if (r > 1.0) {\n        discard;\n      }\n\n      gl_FragColor = vec4(vColor, 1.0) * alpha;\n    } else {\n      if (vScale < 0.3) {\n        vec2 m = uv - vec2(0.5, 0.5);\n        float dist = radius - sqrt(dot(m, m));\n        if (dist > border || dist > 0.0)\n          gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0);\n        else discard;\n      } else if (vScale < 1.5) {\n        distance = 0.25;\n        if (vScale > 1.2) {\n          border = 0.5 - (vScale / 10.0) * 1.9;\n        } else {\n          border = 0.25;\n        }\n\n        vec2 m = uv - vec2(0.5, 0.5);\n        float dist = radius - sqrt(dot(m, m));\n\n        float sm = smoothstep(0.0, distance, dist);\n        float sm2 = smoothstep(border, border - distance, dist);\n        float alpha = sm*sm2;\n\n        float tm = smoothstep(border, border + distance, dist);\n\n        if (dist > border || dist > 0.0)\n          gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);\n        else discard;\n\n      } else {\n        distance = 0.02;\n        if (vScale < 3.0) {\n          border = distance + 0.025;\n        } else {\n          border = distance + 0.02;\n        }\n\n        vec2 m = uv - vec2(0.5, 0.5);\n        float dist = radius - sqrt(dot(m, m));\n\n        float sm = smoothstep(0.0, distance, dist);\n        float sm2 = smoothstep(border, border - distance, dist);\n        float alpha = sm*sm2;\n\n        float tm = smoothstep(border, border + distance, dist);\n\n        if (dist > border)\n          gl_FragColor = vec4(texture2D(textureMap, vec2((v_sprite.s + v_sprite.p * uv.x), (v_sprite.t + v_sprite.q * uv.y))).rgb, tm);\n        else if (dist > 0.0)\n          gl_FragColor = vec4(vColor, alpha);\n        else discard;\n      }\n    }\n  }\n";function a(t){i.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:i.UniformsUtils.clone(i.ShaderLib.line.uniforms),vertexShader:i.ShaderLib.line.vertexShader,fragmentShader:i.ShaderLib.line.fragmentShader}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},useColor:{enumerable:!0,get:function(){return this.uniforms.useColor.value},set:function(t){this.uniforms.useColor.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(t)}function d(){i.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.addAttribute("position",new i.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.addAttribute("uv",new i.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}var h,c,l,u;function _(t,e){i.Mesh.call(this),this.type="LineSegments2",this.geometry=void 0!==t?t:new d,this.material=void 0!==e?e:new a({color:16777215*Math.random()})}function f(t,e){_.call(this),this.type="Line2",this.geometry=void 0!==t?t:new i.LineGeometry,this.material=void 0!==e?e:new i.LineMaterial({color:16777215*Math.random()})}i.UniformsLib.line={resolution:{value:new i.Vector2(1,1)},dashScale:{value:1},useColor:{value:0},dashSize:{value:1},gapSize:{value:1}},i.ShaderLib.line={uniforms:i.UniformsUtils.merge([i.UniformsLib.common,i.UniformsLib.fog,i.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\t\tattribute float linewidth;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float useColor;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tif (useColor == 1.0) {\n\t\t\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t\t\t} else {\n\t\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\t\t\t}\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"},a.prototype=Object.create(i.ShaderMaterial.prototype),a.prototype.constructor=a,a.prototype.isLineMaterial=!0,a.prototype.copy=function(t){return i.ShaderMaterial.prototype.copy.call(this,t),this.color.copy(t.color),this.resolution=t.resolution,this},d.prototype=Object.assign(Object.create(i.InstancedBufferGeometry.prototype),{constructor:d,isLineSegmentsGeometry:!0,applyMatrix:function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(t.applyToBufferAttribute(e),t.applyToBufferAttribute(n),e.data.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new i.InstancedInterleavedBuffer(e,6,1);return this.addAttribute("instanceStart",new i.InterleavedBufferAttribute(n,3,0)),this.addAttribute("instanceEnd",new i.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new i.InstancedInterleavedBuffer(e,6,1);return this.addAttribute("instanceColorStart",new i.InterleavedBufferAttribute(n,3,0)),this.addAttribute("instanceColorEnd",new i.InterleavedBufferAttribute(n,3,3)),this},fromWireframeGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromEdgesGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromMesh:function(t){return this.fromWireframeGeometry(new i.WireframeGeometry(t.geometry)),this},fromLineSegements:function(t){var e=t.geometry;return e.isGeometry?this.setPositions(e.vertices):e.isBufferGeometry&&this.setPositions(e.position.array),this},computeBoundingBox:(c=new i.Box3,function(){null===this.boundingBox&&(this.boundingBox=new i.Box3);var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),c.setFromBufferAttribute(e),this.boundingBox.union(c))}),computeBoundingSphere:(h=new i.Vector3,function(){null===this.boundingSphere&&(this.boundingSphere=new i.Sphere),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){var n=this.boundingSphere.center;this.boundingBox.getCenter(n);for(var s=0,r=0,o=t.count;r<o;r++)h.fromBufferAttribute(t,r),s=Math.max(s,n.distanceToSquared(h)),h.fromBufferAttribute(e,r),s=Math.max(s,n.distanceToSquared(h));this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error("LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},clone:function(){},copy:function(t){return this}}),_.prototype=Object.assign(Object.create(i.Mesh.prototype),{constructor:_,isLineSegments2:!0,computeLineDistances:(l=new i.Vector3,u=new i.Vector3,function(){for(var t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,s=new Float32Array(2*e.data.count),r=0,o=0,a=e.data.count;r<a;r++,o+=2)l.fromBufferAttribute(e,r),u.fromBufferAttribute(n,r),s[o]=0===o?0:s[o-1],s[o+1]=s[o]+l.distanceTo(u);var d=new i.InstancedInterleavedBuffer(s,2,1);return t.addAttribute("instanceDistanceStart",new i.InterleavedBufferAttribute(d,1,0)),t.addAttribute("instanceDistanceEnd",new i.InterleavedBufferAttribute(d,1,1)),this}),copy:function(t){return this}}),f.prototype=Object.assign(Object.create(_.prototype),{constructor:f,isLine2:!0,copy:function(t){return this}});class p{constructor(t){this.onEvent=new s,this._options={},this._container=document.body,this._fov=75,this._far=1e4,this._nodes=[],this._edges=[],this._animationFrameRequestId=null,this._center=null,this._hoveredNode=null,this._hoveredNodeID=null,this._dragInProgress=!1,this._dragging=!1,this._plane=new i.Plane,this._raycaster=new i.Raycaster,this._intersection=new i.Vector3,this._offset=new i.Vector3,this._textureWidth=0,this._textureHeight=0,this._textureIndex=0,this._nodeImageToIndex={},this.options=t,this.options.container&&(this._container=this.options.container,this._container.innerHTML=""),this._setupScene(),this._setupCamera(),this._setupRenderer(),this._controls=new t.controls(this._camera,this._container),this._controls.init(),this._controls.onChange.on("scale",t=>{this._nodesMaterial&&(this._nodesMaterial.uniforms.scale.value=t,this._nodesMaterial.needsUpdate=!0,this._nodesPickingMaterial.uniforms.scale.value=t,this._nodesPickingMaterial.needsUpdate=!0)}),this._controls.onChange.on("mousemove",t=>{if(this._dragging){const e=this._container.getBoundingClientRect(),n=new i.Vector3;n.x=t.x/e.width*2-1,n.y=-t.y/e.height*2+1;let s={x:this._hoveredNode.x,y:this._hoveredNode.y};if(this._dragInProgress)this._raycaster.setFromCamera(n,this._camera),this._raycaster.ray.intersectPlane(this._plane,this._intersection),s=this._intersection.sub(this._offset).clone();else{const t=new i.Vector3;this._camera.getWorldDirection(t),this._plane.setFromNormalAndCoplanarPoint(t,new i.Vector3(this._hoveredNode.x,this._hoveredNode.y,0)),this._raycaster.setFromCamera(n,this._camera),this._raycaster.ray.intersectPlane(this._plane,this._intersection),this._offset.copy(this._intersection).sub(new i.Vector3(this._hoveredNode.x,this._hoveredNode.y,0)),s=this._intersection.sub(this._offset).clone(),this._dragInProgress=!0}null!==this._hoveredNodeID&&(this._nodesGeometry.attributes.translation.setXYZ(this._hoveredNodeID,s.x,s.y,0),this._nodesPickingGeometry.attributes.translation.setXYZ(this._hoveredNodeID,s.x,s.y,0)),this._hoveredNode.x=s.x,this._hoveredNode.y=s.y;const r=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeMoving",{node:this._hoveredNode,...r,scale:this._controls.scale}),this._nodesGeometry.attributes.translation.needsUpdate=!0,this._nodesPickingGeometry.attributes.translation.needsUpdate=!0;const o=this._constructLines(this._edges);this._lineGeometry.setPositions(o.positions),this._lineGeometry.attributes.instanceStart.data.needsUpdate=!0,this._lineGeometry.attributes.instanceEnd.data.needsUpdate=!0}else this._testNode(t)}),this._controls.onChange.on("contextmenu",()=>{if(null!==this._hoveredNode){const t=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeContextMenu",{node:this._hoveredNode,...t,scale:this._controls.scale})}}),this._controls.onChange.on("mousedown",()=>{if(null!==this._hoveredNode){const t=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeClick",{node:this._hoveredNode,...t,scale:this._controls.scale}),this._controls.enabled=!1,this._dragging=!0}}),this._controls.onChange.on("mouseup",()=>{this._controls.enabled=!0,this._dragging=!1,this._dragInProgress=!1}),this._pickingNodesScene=new i.Scene,this._pickingNodesScene.background=new i.Color(0);const e=this._container.getBoundingClientRect();this._pickingTexture=new i.WebGLRenderTarget(e.width,e.height),this._pickingTexture.texture.minFilter=i.LinearFilter,this._createTextureMap(),this._renderLoop(),window.addEventListener("resize",()=>{const t=this._container.getBoundingClientRect();this._renderer.setSize(t.width,t.height),this._camera.aspect=t.width/t.height,this._camera.updateProjectionMatrix(),this._pickingTexture=new i.WebGLRenderTarget(t.width,t.height)})}set options(t){this._options=t}get options(){return this._options}setData(t){this._nodes=t.nodes,this._edges=t.links,t.center&&(this._center=t.nodes.find(e=>+e.id==+t.center),this._center&&this._controls.setTransform(this._center)),this._drawEdges(),this._drawNodes(),this._drawArrows()}stopRenderLoop(){this._animationFrameRequestId&&cancelAnimationFrame(this._animationFrameRequestId),this._animationFrameRequestId=null}resumeRenderLoop(){this._animationFrameRequestId||this._renderLoop()}destroy(){this._disposeMesh(),this._disposeTextures(),this._disposeMaterials(),this._disposeGeometries(),this.stopRenderLoop(),this._disposeRenderer(),this._container.innerHTML=""}_disposeMesh(){this._lineMesh&&this._scene.remove(this._lineMesh),this._nodeMesh&&this._scene.remove(this._nodeMesh),this._nodesPickingsMesh&&this._pickingNodesScene.remove(this._nodesPickingsMesh)}_disposeGeometries(){this._nodesGeometry&&this._nodesGeometry.dispose(),this._nodesPickingGeometry&&this._nodesPickingGeometry.dispose(),this._lineGeometry&&this._lineGeometry.dispose()}_disposeRenderer(){this._renderer&&this._renderer.dispose()}_disposeMaterials(){this._nodesMaterial&&this._nodesMaterial.dispose(),this._nodesPickingMaterial&&this._nodesPickingMaterial.dispose(),this._lineMaterial&&this._lineMaterial.dispose()}_disposeTextures(){this._textureMap&&this._textureMap.dispose(),this._pickingTexture&&this._pickingTexture.dispose()}_testNode(t){this._renderer.render(this._pickingNodesScene,this._camera,this._pickingTexture);const e=new Uint8Array(4);this._renderer.readRenderTargetPixels(this._pickingTexture,t.x,this._pickingTexture.height-t.y,1,1,e);const n=e[0]<<16|e[1]<<8|e[2];if(n){if(this._hoveredNodeID!==n-1){null!==this._hoveredNode&&this._setNodeColor(this._hoveredNode.color),this._hoveredNode=this._nodes[n-1],this._hoveredNodeID=n-1,this._setNodeColor(16711680);const t=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeHover",{node:this._hoveredNode,...t,scale:this._controls.scale})}}else null!==this._hoveredNode&&(this._setNodeColor(this._hoveredNode.color),this.onEvent.emit("nodeUnhover",{node:this._hoveredNode}),this._hoveredNode=null,this._hoveredNodeID=null)}_setNodeColor(t){const e=new i.Color;e.setHex(t),null!==this._hoveredNodeID&&(this._nodeColorAttribute.setXYZ(this._hoveredNodeID,e.r,e.g,e.b),this._nodeColorAttribute.needsUpdate=!0)}_translateCoordinates(t,e){const n=new i.Vector3(t,e,0),s=.5*this._renderer.context.canvas.width,r=.5*this._renderer.context.canvas.height;return n.project(this._camera),n.x=n.x*s+s,n.y=-n.y*r+r,{x:n.x,y:n.y}}_drawNodes(){const t=new i.Color,e=new Float32Array(3*this._nodes.length),n=new Float32Array(3*this._nodes.length),s=new Float32Array(this._nodes.length),a=new Float32Array(this._nodes.length);for(let i=0,r=0,o=this._nodes.length;i<o;i++,r+=3)e[r+0]=this._nodes[i].x,e[r+1]=this._nodes[i].y,e[r+2]=0,t.setHex(this._nodes[i].color),n[r+0]=t.r,n[r+1]=t.g,n[r+2]=t.b,s[i]=this._nodes[i].size,this._nodes[i].img?a[i]=this._loadImage(this._nodes[i].img):a[i]=-1;const d=new i.BufferGeometry;this._nodesGeometry=new i.InstancedBufferGeometry,this._nodesGeometry.index=d.index,this._nodesGeometry.attributes=d.attributes,this._nodesGeometry.addAttribute("position",new i.BufferAttribute(new Float32Array([0,0,0]),3)),this._nodeTranslateAttribute=new i.InstancedBufferAttribute(e,3),this._nodeColorAttribute=new i.InstancedBufferAttribute(n,3),this._nodesGeometry.addAttribute("translation",this._nodeTranslateAttribute),this._nodesGeometry.addAttribute("color",this._nodeColorAttribute),this._nodesGeometry.addAttribute("size",new i.InstancedBufferAttribute(s,1)),this._nodesGeometry.addAttribute("image",new i.InstancedBufferAttribute(a,1)),this._nodesMaterial=new i.RawShaderMaterial({depthTest:!1,fragmentShader:o,transparent:!1,uniforms:{scale:{type:"f",value:this._controls?this._controls.scale:1},spriteDim:{value:new i.Vector2(this._textureWidth,this._textureHeight)},textureDim:{value:new i.Vector2(2048,2048)},textureMap:{type:"t",value:this._textureMap},useColor:{type:"f",value:0}},vertexShader:r}),this._nodeMesh=new i.Points(this._nodesGeometry,this._nodesMaterial),this._nodeMesh.frustumCulled=!1,this._nodeMesh.renderOrder=10,this._scene.add(this._nodeMesh);const h=new Float32Array(3*this._nodes.length);for(let e=0,n=0,i=this._nodes.length;e<i;e++,n+=3)t.setHex(e+1),h[n+0]=t.r,h[n+1]=t.g,h[n+2]=t.b;this._nodesPickingMaterial=new i.RawShaderMaterial({fragmentShader:o,uniforms:{scale:{type:"f",value:this._controls?this._controls.scale:1},useColor:{type:"f",value:1}},vertexShader:r});const c=this._nodeMesh.clone();this._nodesPickingGeometry=c.geometry.clone(),this._nodesPickingGeometry.addAttribute("color",new i.InstancedBufferAttribute(h,3)),this._nodesPickingsMesh=new i.Points(this._nodesPickingGeometry,this._nodesPickingMaterial),this._nodesPickingsMesh.frustumCulled=!1,this._pickingNodesScene.add(this._nodesPickingsMesh),this._pickingNodesScene.updateMatrixWorld(!0)}_drawEdges(){const t=this._constructLines(this._edges);this._lineGeometry=new d,this._lineGeometry.setPositions(t.positions),this._lineGeometry.setColors(t.colors),this._lineGeometry.addAttribute("linewidth",new i.InstancedBufferAttribute(new Float32Array(t.sizes),1)),this._lineGeometry.attributes.instanceStart.data.dynamic=!0,this._lineGeometry.attributes.instanceEnd.data.dynamic=!0,this._lineMaterial=new a({dashed:!1,vertexColors:i.VertexColors});const e=this._container.getBoundingClientRect();this._lineMaterial.useColor=1,this._lineMaterial.resolution.set(e.width,e.height),this._lineMesh=new f(this._lineGeometry,this._lineMaterial),this._lineMesh.computeLineDistances(),this._scene.add(this._lineMesh)}_drawArrows(){}_setupScene(){this._scene=new i.Scene,this._scene.background=new i.Color(this.options.backgroundColor||"white")}_setupCamera(){const t=this._container.getBoundingClientRect();this._camera=new i.PerspectiveCamera(this._fov,t.width/t.height,.1,this._far),this._camera.lookAt(0,0,0)}_setupRenderer(){this._renderer=new i.WebGLRenderer({alpha:!0,antialias:!0}),this._renderer.setPixelRatio(window.devicePixelRatio);const t=this._container.getBoundingClientRect();this._renderer.setSize(t.width,t.height),this._container.appendChild(this._renderer.domElement)}_renderLoop(){this._renderer.render(this._scene,this._camera),this._animationFrameRequestId=requestAnimationFrame(this._renderLoop.bind(this))}_createTextureMap(){this._textureCanvas=document.createElement("canvas"),this._textureCanvas.width=2048,this._textureCanvas.height=2048,this._textureHeight=2048/Math.sqrt(256),this._textureWidth=2048/Math.sqrt(256);const t=this._textureCanvas.getContext("2d");t&&(t.fillStyle="white",t.clearRect(0,0,2048,2048)),this._textureMap=new i.CanvasTexture(this._textureCanvas),this._textureMap.flipY=!1}_loadImage(t){const e=this._textureCanvas.getContext("2d");if(!e)return-1;const n=this._textureIndex;this._textureIndex+=1,this._nodeImageToIndex[t]=n;const i=new Image;return i.onload=(()=>{const t=n*this._textureWidth%2048,s=Math.floor(n*this._textureWidth/2048)*this._textureHeight;e.drawImage(i,0,0,i.width,i.height,t,s,this._textureWidth,this._textureHeight),this._textureMap.needsUpdate=!0}),i.src=t,n}_constructLines(t){const e=performance.now(),n=[],s=[],r=[],o=new i.Color;t.forEach(t=>{const e=Math.atan2(t.target.y-t.source.y,t.target.x-t.source.x),a=t.source.x+25*Math.cos(e),d=t.source.y+25*Math.sin(e),h=t.target.x-25*Math.cos(e),c=t.target.y-25*Math.sin(e);if(t.source.x===t.target.x&&t.source.y===t.target.y){const e=new i.Vector3(t.source.x,t.source.y||0,0),a=new i.Vector3(t.target.x,t.target.y||0,0),d=15*t.source.size,h=-0,c=h+Math.PI/2,l=new i.CubicBezierCurve3(e,new i.Vector3(d*Math.cos(c),d*Math.sin(c),0).add(e),new i.Vector3(d*Math.cos(h),d*Math.sin(h),0).add(e),a).getPoints(50);let u;for(let e=0;e<l.length-1;e+=2)u?(n.push(u.x,u.y,0,l[e].x,l[e].y,0,l[e].x,l[e].y,0,l[e+1].x,l[e+1].y,0),r.push(t.size,t.size),o.setHex(t.color),s.push(o.r,o.g,o.b,o.r,o.g,o.b,o.r,o.g,o.b,o.r,o.g,o.b)):(n.push(l[e].x,l[e].y,0,l[e+1].x,l[e+1].y,0),r.push(t.size),o.setHex(t.color),s.push(o.r,o.g,o.b,o.r,o.g,o.b)),u=l[e+1]}else n.push(a,d,0,h,c,0),r.push(t.size),o.setHex(t.color),s.push(o.r,o.g,o.b,o.r,o.g,o.b)});const a=performance.now();return console.log("line generated: ",a-e),{colors:s,positions:n,sizes:r}}}n.d(e,"PretyGraph",function(){return p})}])});