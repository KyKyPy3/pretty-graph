!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("three")):"function"==typeof define&&define.amd?define("prettyGraphCore",["three"],t):"object"==typeof exports?exports.prettyGraphCore=t(require("three")):e.prettyGraphCore=t(e.three)}("undefined"!=typeof self?self:this,function(e){return function(e){var t={};function i(n){if(t[n])return t[n].exports;var s=t[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(n,s,function(t){return e[t]}.bind(null,s));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=1)}([function(t,i){t.exports=e},function(e,t,i){"use strict";i.r(t);var n=i(0);class s{constructor(){this.events={}}on(e,t){return"object"!=typeof this.events[e]&&(this.events[e]=[]),this.events[e].push(t),()=>this.removeListener(e,t)}removeListener(e,t){if("object"!=typeof this.events[e])return;const i=this.events[e].indexOf(t);i>-1&&this.events[e].splice(i,1)}removeAllListeners(){Object.keys(this.events).forEach(e=>this.events[e].splice(0,this.events[e].length))}emit(e,...t){"object"==typeof this.events[e]&&[...this.events[e]].forEach(e=>e.apply(this,t))}once(e,t){const i=this.on(e,(...e)=>{i(),t.apply(this,e)});return i}}class r extends n.EventDispatcher{constructor(){super(),this.textureWidth=0,this.textureHeight=0,this.canvasHeight=4096,this.canvasWidth=4096,this._nodeImageToIndex={},this._textureIndex=0,this.canvas=document.createElement("canvas"),this.canvas.width=this.canvasWidth,this.canvas.height=this.canvasHeight,this.textureWidth=this.canvasWidth/32,this.textureHeight=this.canvasHeight/32,this._ctx=this.canvas.getContext("2d"),this._ctx&&(this._ctx.fillStyle="white",this._ctx.clearRect(0,0,this.canvas.width,this.canvas.height)),this.textureMap=new n.CanvasTexture(this.canvas),this.textureMap.flipY=!1}dispose(){this.textureMap.dispose()}loadImage(e){if(void 0!==this._nodeImageToIndex[e])return this._nodeImageToIndex[e];if(this._ctx){const t=this._textureIndex;this._textureIndex+=1,this._nodeImageToIndex[e]=t;const i=new Image;return i.onload=(()=>{const e=t*this.textureWidth%this.canvasWidth,n=Math.floor(t*this.textureWidth/this.canvasWidth)*this.textureHeight;this._ctx&&this._ctx.drawImage(i,0,0,i.width,i.height,e,n,this.textureWidth,this.textureHeight),this.textureMap.needsUpdate=!0,this.dispatchEvent({index:t,type:"imageLoaded"})}),i.src=e,t}return-1}}const o="\n  precision mediump float;\n\n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float scale;\n  uniform float nodeScalingFactor;\n  uniform vec2 spriteDim;\n  uniform vec2 textureDim;\n\n  attribute vec3 position;    // blueprint's vertex positions\n  attribute vec3 color;       // only used for raycasting\n  attribute vec3 translation; // x y translation offsets for an instance\n  attribute float size;\n  attribute float image;\n\n  varying vec3 vColor;\n  varying float vScale;\n  varying float vNodeScaleFactor;\n  varying float vSize;\n  varying highp vec4 v_sprite;\n\n  void main() {\n    vColor = color;\n    vScale = scale;\n    vSize = size;\n    vNodeScaleFactor = nodeScalingFactor;\n\n    highp vec2 sp = vec2(mod((image * spriteDim.x), textureDim.x), floor((image * spriteDim.x) / textureDim.y) * spriteDim.y);\n    v_sprite = vec4(sp.x / textureDim.x, sp.y / textureDim.y, spriteDim.x / textureDim.x, spriteDim.y / textureDim.y);\n\n    vec3 pos = position + translation;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n\n    if (size * scale * nodeScalingFactor > 12.0) {\n      gl_PointSize = size * scale * nodeScalingFactor;\n    } else {\n      gl_PointSize = 12.0;\n    }\n  }\n",a="\n  precision mediump float;\n\n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform vec2 spriteDim;\n  uniform vec2 textureDim;\n  uniform float scale;\n  uniform float nodeScalingFactor;\n\n  attribute vec3 position;    // blueprint's vertex positions\n  attribute vec3 translation; // x y translation offsets for an instance\n  attribute float image;\n  attribute float size;\n  attribute vec2 uv;\n\n  varying highp vec4 v_sprite;\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n\n    highp vec2 sp = vec2(mod((image * spriteDim.x), textureDim.x), floor((image * spriteDim.x) / textureDim.y) * spriteDim.y);\n    v_sprite = vec4(sp.x / textureDim.x, sp.y / textureDim.y, spriteDim.x / textureDim.x, spriteDim.y / textureDim.y);\n\n    vec3 pos = position + translation;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos.x + nodeScalingFactor * (size / 2.0), pos.y, pos.z, 1.0);\n  }\n",d="\n  #ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n  #endif\n\n  precision highp float;\n\n  uniform sampler2D textureMap;\n\n  varying float vScale;\n  varying float vNodeScaleFactor;\n  varying float vSize;\n  varying vec3 vColor;\n  varying highp vec4 v_sprite;\n\n  void main() {\n    vec2 uv = vec2( gl_PointCoord.x, gl_PointCoord.y );\n    float distance = 0.2;\n    float border = 0.2;\n    float radius = 0.5;\n\n    vec2 m = uv - vec2(0.5, 0.5);\n    float dist = radius - sqrt(dot(m, m));\n\n    if (vSize * vNodeScaleFactor * vScale > 40.0) {\n      distance = 0.02;\n      if (vScale < 2.0) {\n        border = distance + 0.04;\n      } else if (vScale < 4.0) {\n        border = distance + 0.03;\n      } else {\n        border = distance + 0.02;\n      }\n\n      float sm = smoothstep(0.0, distance, dist);\n      float sm2 = smoothstep(border, border - distance, dist);\n      float alpha = sm*sm2;\n\n      float tm = smoothstep(border, border + distance, dist);\n\n      if (dist > border)\n        gl_FragColor = vec4(texture2D(textureMap, vec2((v_sprite.s + v_sprite.p * uv.x), (v_sprite.t + v_sprite.q * uv.y))).rgb, tm);\n      else if (dist > 0.0)\n        gl_FragColor = vec4(vColor, alpha);\n      else discard;\n    } else {\n      distance = 0.02 - vScale / 100.0;\n      border = 0.25 - (vScale / vNodeScaleFactor);\n\n      float sm = smoothstep(0.0, distance, dist);\n      float sm2 = smoothstep(border, border - distance, dist);\n      float alpha = sm*sm2;\n\n      if (dist > border)\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      else if (dist > 0.0)\n        gl_FragColor = vec4(vColor, alpha);\n      else discard;\n    }\n  }\n",h="\n  precision highp float;\n\n  uniform sampler2D textureMap;\n\n  varying highp vec4 v_sprite;\n  varying vec2 vUv;\n\n  void main() {\n    vec2 uv = vec2( vUv.x, 1.0 - vUv.y );\n    gl_FragColor = texture2D(textureMap, vec2((v_sprite.s + v_sprite.p * uv.x), (v_sprite.t + v_sprite.q * uv.y)));\n  }\n",c="\n  precision mediump float;\n\n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float nodeScalingFactor;\n  uniform float scale;\n\n  attribute vec3 position;    // blueprint's vertex positions\n  attribute vec3 color;       // only used for raycasting\n  attribute vec3 translation; // x y translation offsets for an instance\n  attribute float size;\n\n  varying vec3 vColor;\n\n  void main() {\n    vColor = color;\n\n    vec3 pos = position + translation;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n\n    gl_PointSize = size * scale * nodeScalingFactor;\n  }\n",l="\n  #ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n  #endif\n\n  precision highp float;\n\n  varying vec3 vColor;\n\n  void main() {\n    float r = 0.0, delta = 0.0, alpha = 1.0;\n    vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n    r = dot(cxy, cxy);\n    if (r > 1.0) {\n      discard;\n    }\n\n    gl_FragColor = vec4(vColor, 1.0) * alpha;\n  }\n";class _ extends n.EventDispatcher{constructor(){super(),this.textureWidth=0,this.textureHeight=0,this.canvasHeight=4096,this.canvasWidth=4096,this._textOptionsToIndex={},this._textureIndex=0,this.canvas=document.createElement("canvas"),this.canvas.width=this.canvasWidth,this.canvas.height=this.canvasHeight,this.textureWidth=this.canvasWidth/8,this.textureHeight=30,this._ctx=this.canvas.getContext("2d"),this._ctx&&(this._ctx.fillStyle="white",this._ctx.clearRect(0,0,this.canvas.width,this.canvas.height)),this.textureMap=new n.CanvasTexture(this.canvas),this.textureMap.flipY=!1}dispose(){this.textureMap.dispose()}drawText(e,t){const i=e;if(void 0!==this._textOptionsToIndex[i])return this._textOptionsToIndex[i];if(this._ctx){const n=this._textureIndex;this._textureIndex+=1,this._textOptionsToIndex[i]=n;const s=18/this.textureWidth,r=Math.round(s*this.textureWidth),o=n*this.textureWidth%this.canvasWidth,a=Math.floor(n*this.textureWidth/this.canvasWidth)*this.textureHeight;return this._ctx.beginPath(),this._ctx.fillStyle="white",this._ctx.clearRect(o,a,this.textureWidth,this.textureHeight),this._ctx.beginPath(),this._ctx.fillStyle=t.color,this._ctx.font=r+"px "+t.font,this._ctx.textAlign="start",this._ctx.textBaseline="middle",this._ctx.fillText(e,o+5,a+.5*this.textureHeight),this.textureMap.needsUpdate=!0,n}return-1}}function u(e){n.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:n.UniformsUtils.clone(n.ShaderLib.line.uniforms),vertexShader:n.ShaderLib.line.vertexShader,fragmentShader:n.ShaderLib.line.fragmentShader}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},useColor:{enumerable:!0,get:function(){return this.uniforms.useColor.value},set:function(e){this.uniforms.useColor.value=e}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(e){this.uniforms.dashSize.value=e}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(e){this.uniforms.gapSize.value=e}},scale:{enumerable:!0,get:function(){return this.uniforms.scale.value},set:function(e){this.uniforms.scale.value=e}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}}}),this.setValues(e)}function m(){n.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.addAttribute("position",new n.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.addAttribute("uv",new n.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}var g,p,v,f;function x(e,t){n.Mesh.call(this),this.type="LineSegments2",this.geometry=void 0!==e?e:new m,this.material=void 0!==t?t:new u({color:16777215*Math.random()})}function y(e,t){x.call(this),this.type="Line2",this.geometry=void 0!==e?e:new n.LineGeometry,this.material=void 0!==t?t:new n.LineMaterial({color:16777215*Math.random()})}n.UniformsLib.line={resolution:{value:new n.Vector2(1,1)},dashScale:{value:1},useColor:{value:0},dashSize:{value:1},scale:{value:1},gapSize:{value:1}},n.ShaderLib.line={uniforms:n.UniformsUtils.merge([n.UniformsLib.common,n.UniformsLib.fog,n.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n    uniform vec2 resolution;\n    uniform float scale;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\t\tattribute float linewidth;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth * scale;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float useColor;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tif (useColor == 1.0) {\n\t\t\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t\t\t} else {\n\t\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\t\t\t}\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"},u.prototype=Object.create(n.ShaderMaterial.prototype),u.prototype.constructor=u,u.prototype.isLineMaterial=!0,u.prototype.copy=function(e){return n.ShaderMaterial.prototype.copy.call(this,e),this.color.copy(e.color),this.resolution=e.resolution,this},m.prototype=Object.assign(Object.create(n.InstancedBufferGeometry.prototype),{constructor:m,isLineSegmentsGeometry:!0,applyMatrix:function(e){var t=this.attributes.instanceStart,i=this.attributes.instanceEnd;return void 0!==t&&(e.applyToBufferAttribute(t),e.applyToBufferAttribute(i),t.data.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(e){var t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));var i=new n.InstancedInterleavedBuffer(t,6,1);return this.addAttribute("instanceStart",new n.InterleavedBufferAttribute(i,3,0)),this.addAttribute("instanceEnd",new n.InterleavedBufferAttribute(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(e){var t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));var i=new n.InstancedInterleavedBuffer(t,6,1);return this.addAttribute("instanceColorStart",new n.InterleavedBufferAttribute(i,3,0)),this.addAttribute("instanceColorEnd",new n.InterleavedBufferAttribute(i,3,3)),this},fromWireframeGeometry:function(e){return this.setPositions(e.attributes.position.array),this},fromEdgesGeometry:function(e){return this.setPositions(e.attributes.position.array),this},fromMesh:function(e){return this.fromWireframeGeometry(new n.WireframeGeometry(e.geometry)),this},fromLineSegements:function(e){var t=e.geometry;return t.isGeometry?this.setPositions(t.vertices):t.isBufferGeometry&&this.setPositions(t.position.array),this},computeBoundingBox:(p=new n.Box3,function(){null===this.boundingBox&&(this.boundingBox=new n.Box3);var e=this.attributes.instanceStart,t=this.attributes.instanceEnd;void 0!==e&&void 0!==t&&(this.boundingBox.setFromBufferAttribute(e),p.setFromBufferAttribute(t),this.boundingBox.union(p))}),computeBoundingSphere:(g=new n.Vector3,function(){null===this.boundingSphere&&(this.boundingSphere=new n.Sphere),null===this.boundingBox&&this.computeBoundingBox();var e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(void 0!==e&&void 0!==t){var i=this.boundingSphere.center;this.boundingBox.getCenter(i);for(var s=0,r=0,o=e.count;r<o;r++)g.fromBufferAttribute(e,r),s=Math.max(s,i.distanceToSquared(g)),g.fromBufferAttribute(t,r),s=Math.max(s,i.distanceToSquared(g));this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error("LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},clone:function(){},copy:function(e){return this}}),x.prototype=Object.assign(Object.create(n.Mesh.prototype),{constructor:x,isLineSegments2:!0,computeLineDistances:(v=new n.Vector3,f=new n.Vector3,function(){for(var e=this.geometry,t=e.attributes.instanceStart,i=e.attributes.instanceEnd,s=new Float32Array(2*t.data.count),r=0,o=0,a=t.data.count;r<a;r++,o+=2)v.fromBufferAttribute(t,r),f.fromBufferAttribute(i,r),s[o]=0===o?0:s[o-1],s[o+1]=s[o]+v.distanceTo(f);var d=new n.InstancedInterleavedBuffer(s,2,1);return e.addAttribute("instanceDistanceStart",new n.InterleavedBufferAttribute(d,1,0)),e.addAttribute("instanceDistanceEnd",new n.InterleavedBufferAttribute(d,1,1)),this}),copy:function(e){return this}}),y.prototype=Object.assign(Object.create(x.prototype),{constructor:y,isLine2:!0,copy:function(e){return this}});class b{constructor(e){this.onEvent=new s,this.nodeScalingFactor=7,this._options={},this._container=document.body,this._fov=75,this._far=1e4,this._nodes=[],this._edges=[],this._animationFrameRequestId=null,this._center=null,this._hoveredNode=null,this._hoveredEdge=null,this._hoveredEdgeID=null,this._dragInProgress=!1,this._dragging=!1,this._plane=new n.Plane,this._raycaster=new n.Raycaster,this._intersection=new n.Vector3,this._offset=new n.Vector3,this._indexedNodes={},this._colorToNodeID={},this.options=e,this.options.container&&(this._container=this.options.container,e.clearContainer&&(this._container.innerHTML="")),this._setupScene(),this._setupCamera(),this._setupRenderer(),this._controls=new e.controls(this._camera,this._container),this._controls.init(),this._controls.addEventListener("scale",this._onScale.bind(this)),this._controls.addEventListener("mousemove",this._onMouseMove.bind(this)),this._controls.addEventListener("contextmenu",this._onContextMenu.bind(this)),this._controls.addEventListener("dblclick",this._onDblClick.bind(this)),this._controls.addEventListener("click",this._onClick.bind(this)),this._controls.addEventListener("mousedown",this._onMouseDown.bind(this)),this._controls.addEventListener("mouseup",this._onMouseUp.bind(this)),this._imageLoaded=(()=>{this._render()}),this._imageCanvas=new r,this._textCanvas=new _,this._render(),window.addEventListener("resize",()=>{const e=this._container.getBoundingClientRect();this._renderer.setSize(e.width,e.height),this._camera.aspect=e.width/e.height,this._camera.updateProjectionMatrix(),this._pickingTexture=new n.WebGLRenderTarget(e.width,e.height),this._render()})}set options(e){this._options=e}get options(){return this._options}setData(e,t={animate:!1}){this._nodes=e.nodes,this._edges=e.links;const i=JSON.parse(JSON.stringify(this._indexedNodes));this._indexingNodes(),e.center&&(this._center=this._indexedNodes[e.center],this._center&&this._controls.setTransform(this._center)),this._disposeMesh(),this._disposeMaterials(),this._disposeGeometries(),this._disposeTextures(),this._renderer.clear(),this._renderer.renderLists.dispose(),this._setupScene(),this._setupPickingScene();const s=this._container.getBoundingClientRect();if(this._pickingTexture=new n.WebGLRenderTarget(s.width,s.height),this._pickingTexture.texture.minFilter=n.LinearFilter,this._imageCanvas.addEventListener("imageLoaded",this._imageLoaded),t.animate){for(const e in this._indexedNodes)i[e]?(this._indexedNodes[e].toX=this._indexedNodes[e].x,this._indexedNodes[e].toY=this._indexedNodes[e].y,this._indexedNodes[e].fromX=i[e].x,this._indexedNodes[e].fromY=i[e].y,this._indexedNodes[e].x=i[e].x,this._indexedNodes[e].y=i[e].y):(this._indexedNodes[e].toX=this._indexedNodes[e].x,this._indexedNodes[e].toY=this._indexedNodes[e].y,this._center&&this._indexedNodes[e].id===this._center.id?(this._indexedNodes[e].fromX=this._center.x,this._indexedNodes[e].fromY=this._center.y,this._indexedNodes[e].x=this._center.x,this._indexedNodes[e].y=this._center.y):(this._indexedNodes[e].fromX=this._getRandomFromRange(-s.width,s.width),this._indexedNodes[e].fromY=this._getRandomFromRange(-s.height,s.height),this._indexedNodes[e].x=this._getRandomFromRange(-s.width,s.width),this._indexedNodes[e].y=this._getRandomFromRange(-s.height,s.height)));this._drawEdges(),this._drawArrows(),this._drawLabels(),this._drawNodes(),this._render(),this._animate()}else this._drawEdges(),this._drawArrows(),this._drawLabels(),this._drawNodes(),this._render()}stopRenderLoop(){this._animationFrameRequestId&&cancelAnimationFrame(this._animationFrameRequestId),this._animationFrameRequestId=null}resumeRenderLoop(){this._animationFrameRequestId||this._render()}getNodeByID(e){const t=this._indexedNodes[e];return{node:t,...this._translateCoordinates(t.x,t.y),scale:this._controls.scale}}destroy(){this._disposeMesh(),this._disposeTextures(),this._disposeMaterials(),this._disposeGeometries(),this.stopRenderLoop(),this._disposeRenderer(),this._container.innerHTML=""}_onMouseMove({position:e}){if(this._dragging){const t=this._container.getBoundingClientRect(),i=new n.Vector3;i.x=e.x/t.width*2-1,i.y=-e.y/t.height*2+1;let s={x:this._hoveredNode.x,y:this._hoveredNode.y};if(this._dragInProgress)this._raycaster.setFromCamera(i,this._camera),this._raycaster.ray.intersectPlane(this._plane,this._intersection),s=this._intersection.sub(this._offset).clone();else{const e=new n.Vector3;this._camera.getWorldDirection(e),this._plane.setFromNormalAndCoplanarPoint(e,new n.Vector3(this._hoveredNode.x,this._hoveredNode.y,0)),this._raycaster.setFromCamera(i,this._camera),this._raycaster.ray.intersectPlane(this._plane,this._intersection),this._offset.copy(this._intersection).sub(new n.Vector3(this._hoveredNode.x,this._hoveredNode.y,0)),s=this._intersection.sub(this._offset).clone(),this._dragInProgress=!0}null!==this._hoveredNode&&(this._nodesGeometry.attributes.translation.setXYZ(this._hoveredNode.__positionIndex,s.x,s.y,0),this._nodesPickingGeometry.attributes.translation.setXYZ(this._hoveredNode.__positionIndex,s.x,s.y,0),this._labelsGeometry.attributes.translation.setXYZ(this._hoveredNode.__labelIndex,s.x+this._textCanvas.textureWidth/2,s.y,0)),this._hoveredNode.x=s.x,this._hoveredNode.y=s.y;const r=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeMoving",{node:this._hoveredNode,...r,scale:this._controls.scale}),this._nodesGeometry.attributes.translation.needsUpdate=!0,this._nodesPickingGeometry.attributes.translation.needsUpdate=!0,this._labelsGeometry.attributes.translation.needsUpdate=!0;const o=this._constructLines(this._edges);this._lineGeometry.setPositions(o.positions),this._linesPickingGeometry.setPositions(o.positions),this._lineGeometry.attributes.instanceStart.data.needsUpdate=!0,this._lineGeometry.attributes.instanceEnd.data.needsUpdate=!0,this._linesPickingGeometry.attributes.instanceStart.data.needsUpdate=!0,this._linesPickingGeometry.attributes.instanceEnd.data.needsUpdate=!0;const{vertices:a,normals:d}=this._calculateArrowData();this._arrowGeometry.attributes.position.array=a,this._arrowGeometry.attributes.normal.array=d,this._arrowGeometry.attributes.position.needsUpdate=!0,this._arrowGeometry.attributes.normal.needsUpdate=!0,this._render()}else this._testNode(e)||this._testEdge(e)}_onMouseUp(){this._controls.enabled=!0,this._dragging=!1,this._dragInProgress=!1}_onMouseDown({event:e}){if(null!==this._hoveredNode){const t=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeClick",{node:this._hoveredNode,...t,scale:this._controls.scale}),1===e.buttons&&(this._controls.enabled=!1,this._dragging=!0)}}_onClick(){this._hoveredNode||this._hoveredEdge||this.onEvent.emit("workspaceClick")}_onDblClick(){if(null!==this._hoveredNode){const e=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeDblClick",{node:this._hoveredNode,...e,scale:this._controls.scale})}}_onContextMenu(){if(null!==this._hoveredNode){const e=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeContextMenu",{node:this._hoveredNode,...e,scale:this._controls.scale})}}_onScale(e){if(this._nodesMaterial){this._nodesMaterial.uniforms.scale.value=e.scale,this._nodesMaterial.needsUpdate=!0,this._nodesPickingMaterial.uniforms.scale.value=e.scale,this._nodesPickingMaterial.needsUpdate=!0,this._labelsMaterial.uniforms.scale.value=e.scale,this._labelsMaterial.needsUpdate=!0,this._lineMaterial.uniforms.scale.value=e.scale,this._lineMaterial.needsUpdate=!0;const{vertices:t,normals:i}=this._calculateArrowData();if(this._arrowGeometry.attributes.position.array=t,this._arrowGeometry.attributes.normal.array=i,this._arrowGeometry.attributes.position.needsUpdate=!0,this._arrowGeometry.attributes.normal.needsUpdate=!0,this._hoveredNode){const e=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeScaling",{node:this._hoveredNode,...e,scale:this._controls.scale})}this._render()}}_disposeMesh(){this._lineMesh&&this._scene.remove(this._lineMesh),this._arrowMesh&&this._scene.remove(this._arrowMesh),this._nodeMesh&&this._scene.remove(this._nodeMesh),this._labelsMesh&&this._scene.remove(this._labelsMesh),this._nodesPickingsMesh&&this._pickingNodesScene.remove(this._nodesPickingsMesh),this._linePickingMesh&&this._pickingLineScene.remove(this._linePickingMesh)}_disposeGeometries(){this._nodesGeometry&&this._nodesGeometry.dispose(),this._nodesPickingGeometry&&this._nodesPickingGeometry.dispose(),this._lineGeometry&&this._lineGeometry.dispose(),this._linesPickingGeometry&&this._linesPickingGeometry.dispose(),this._arrowGeometry&&this._arrowGeometry.dispose(),this._labelsGeometry&&this._labelsGeometry.dispose()}_disposeRenderer(){this._renderer&&(this._container.removeChild(this._renderer.domElement),this._renderer.clear(),this._renderer.renderLists.dispose(),this._renderer.dispose())}_disposeMaterials(){this._nodesMaterial&&this._nodesMaterial.dispose(),this._nodesPickingMaterial&&this._nodesPickingMaterial.dispose(),this._lineMaterial&&this._lineMaterial.dispose(),this._arrowMaterial&&this._arrowMaterial.dispose(),this._labelsMaterial&&this._labelsMaterial.dispose()}_disposeTextures(){this._imageCanvas.removeEventListener("imageLoaded",this._imageLoaded),this._imageCanvas&&this._imageCanvas.dispose(),this._textCanvas&&this._textCanvas.dispose(),this._pickingTexture&&this._pickingTexture.dispose()}_testNode(e){if(this._pickingTexture){this._renderer.render(this._pickingNodesScene,this._camera,this._pickingTexture);const t=new Uint8Array(4);this._renderer.readRenderTargetPixels(this._pickingTexture,e.x,this._pickingTexture.height-e.y,1,1,t);const i=t[0]<<16|t[1]<<8|t[2];if(i){const e=this._indexedNodes[this._colorToNodeID[i]];if(this._hoveredNode!==e){null!==this._hoveredNode&&this._setNodeColor(this._hoveredNode.color),null!==this._hoveredEdge&&(this._setEdgeColor(this._hoveredEdge.color),this._setEdgeSize(this._hoveredEdge.size)),this._hoveredNode=this._indexedNodes[this._colorToNodeID[i]],this._setNodeColor(16711680);const e=this._translateCoordinates(this._hoveredNode.x,this._hoveredNode.y);this.onEvent.emit("nodeHover",{node:this._hoveredNode,...e,scale:this._controls.scale}),this._render()}return!0}return null!==this._hoveredNode&&(this._setNodeColor(this._hoveredNode.color),this.onEvent.emit("nodeUnhover",{node:this._hoveredNode}),this._hoveredNode=null,this._render()),!1}return!1}_testEdge(e){if(this._pickingTexture){this._renderer.render(this._pickingLineScene,this._camera,this._pickingTexture);const t=new Uint8Array(4);this._renderer.readRenderTargetPixels(this._pickingTexture,e.x,this._pickingTexture.height-e.y,1,1,t);const i=t[0]<<16|t[1]<<8|t[2];i?this._hoveredEdgeID!==i-1&&(null!==this._hoveredEdge&&(this._setEdgeColor(this._hoveredEdge.color),this._setEdgeSize(this._hoveredEdge.size)),null!==this._hoveredNode&&this._setNodeColor(this._hoveredNode.color),this._hoveredEdge=this._edges[i-1],this._hoveredEdgeID=i-1,this._setEdgeColor(16711680),this._setEdgeSize(this._hoveredEdge.size<5?5:this._hoveredEdge.size),this.onEvent.emit("edgeHover",{edge:this._hoveredEdge,...e}),this._render()):null!==this._hoveredEdge&&(this._setEdgeColor(this._hoveredEdge.color),this._setEdgeSize(this._hoveredEdge.size),this.onEvent.emit("edgeUnhover",{edge:this._hoveredEdge}),this._hoveredEdge=null,this._hoveredEdgeID=null,this._render())}}_setEdgeSize(e){if(this._hoveredEdge._lineSizeRange){const t=this._hoveredEdge._lineSizeRange[1]-this._hoveredEdge._lineSizeRange[0];if(t>1)for(let t=this._hoveredEdge._lineSizeRange[0];t<this._hoveredEdge._lineSizeRange[1]/2+2;t++)this._lineGeometry.attributes.linewidth.setX(t,e);else this._lineGeometry.attributes.linewidth.setX(this._hoveredEdge._lineSizeRange[0],e);if(this._lineGeometry.attributes.linewidth.updateRange={offset:this._hoveredEdge._lineSizeRange[0],count:t},this._lineGeometry.attributes.linewidth.needsUpdate=!0,t>1)for(let t=this._hoveredEdge._lineSizeRange[0];t<this._hoveredEdge._lineSizeRange[1]/2+2;t++)this._linesPickingGeometry.attributes.linewidth.setX(t,e);else this._linesPickingGeometry.attributes.linewidth.setX(this._hoveredEdge._lineSizeRange[0],e);this._linesPickingGeometry.attributes.linewidth.updateRange={offset:this._hoveredEdge._lineSizeRange[0],count:t},this._linesPickingGeometry.attributes.linewidth.needsUpdate=!0,this._render()}}_setEdgeColor(e){(new n.Color).setHex(e),null!==this._hoveredEdgeID&&this._render()}_setNodeColor(e){const t=new n.Color;t.setHex(e),null!==this._hoveredNode&&(this._nodeColorAttribute.setXYZ(this._hoveredNode.__positionIndex,t.r,t.g,t.b),this._nodeColorAttribute.needsUpdate=!0,this._render())}_translateCoordinates(e,t){const i=new n.Vector3(e,t,0),s=.5*this._renderer.context.canvas.width,r=.5*this._renderer.context.canvas.height;return i.project(this._camera),i.x=i.x*s+s,i.y=-i.y*r+r,{x:i.x,y:i.y}}_drawNodes(){const e=new n.Color,t=new Float32Array(3*this._nodes.length),i=new Float32Array(3*this._nodes.length),s=new Float32Array(this._nodes.length),r=new Float32Array(this._nodes.length);for(let n=0,o=0,a=this._nodes.length;n<a;n++,o+=3){if(t[o+0]=this._nodes[n].x,t[o+1]=this._nodes[n].y,t[o+2]=0,e.setHex(this._nodes[n].color),i[o+0]=e.r,i[o+1]=e.g,i[o+2]=e.b,s[n]=this._nodes[n].size,this._nodes[n].img){const e=this._imageCanvas.loadImage(this._nodes[n].img);this._nodes[n]._imageIndex=e,r[n]=e}else r[n]=-1;this._nodes[n].__positionIndex=n}const a=new n.BufferGeometry;this._nodesGeometry=new n.InstancedBufferGeometry,this._nodesGeometry.index=a.index,this._nodesGeometry.attributes=a.attributes,this._nodesGeometry.addAttribute("position",new n.BufferAttribute(new Float32Array([0,0,0]),3)),this._nodeTranslateAttribute=new n.InstancedBufferAttribute(t,3),this._nodeTranslateAttribute.setDynamic(!0),this._nodeColorAttribute=new n.InstancedBufferAttribute(i,3),this._nodeColorAttribute.setDynamic(!0),this._nodesGeometry.addAttribute("translation",this._nodeTranslateAttribute),this._nodesGeometry.addAttribute("color",this._nodeColorAttribute),this._nodesGeometry.addAttribute("size",new n.InstancedBufferAttribute(s,1)),this._nodesGeometry.addAttribute("image",new n.InstancedBufferAttribute(r,1)),this._nodesMaterial=new n.RawShaderMaterial({depthTest:!1,fragmentShader:d,transparent:!1,uniforms:{nodeScalingFactor:{type:"f",value:this.nodeScalingFactor},scale:{type:"f",value:this._controls?this._controls.scale:1},spriteDim:{value:new n.Vector2(this._imageCanvas.textureWidth,this._imageCanvas.textureHeight)},textureDim:{value:new n.Vector2(this._imageCanvas.canvasWidth,this._imageCanvas.canvasHeight)},textureMap:{type:"t",value:this._imageCanvas.textureMap}},vertexShader:o}),this._nodeMesh=new n.Points(this._nodesGeometry,this._nodesMaterial),this._nodeMesh.frustumCulled=!1,this._nodeMesh.renderOrder=10,this._scene.add(this._nodeMesh);const h=new Float32Array(3*this._nodes.length);for(let t=0,i=0,n=this._nodes.length;t<n;t++,i+=3)e.setHex(t+1),h[i+0]=e.r,h[i+1]=e.g,h[i+2]=e.b,this._colorToNodeID[t+1]=this._nodes[t].id;this._nodesPickingMaterial=new n.RawShaderMaterial({fragmentShader:l,uniforms:{nodeScalingFactor:{type:"f",value:this.nodeScalingFactor},scale:{type:"f",value:this._controls?this._controls.scale:1}},vertexShader:c});const _=this._nodeMesh.clone();this._nodesPickingGeometry=_.geometry.clone(),this._nodesPickingGeometry.addAttribute("color",new n.InstancedBufferAttribute(h,3)),this._nodesPickingsMesh=new n.Points(this._nodesPickingGeometry,this._nodesPickingMaterial),this._nodesPickingsMesh.frustumCulled=!1,this._pickingNodesScene.add(this._nodesPickingsMesh),this._pickingNodesScene.updateMatrixWorld(!0)}_drawEdges(){const e=this._constructLines(this._edges);this._lineGeometry=new m,this._lineGeometry.setPositions(e.positions),this._lineGeometry.setColors(e.colors),this._lineGeometry.addAttribute("linewidth",new n.InstancedBufferAttribute(new Float32Array(e.sizes),1)),this._lineGeometry.attributes.instanceStart.data.dynamic=!0,this._lineGeometry.attributes.instanceEnd.data.dynamic=!0,this._lineMaterial=new u({dashed:!1,depthTest:!1,scale:this._controls?this._controls.scale:1,vertexColors:n.VertexColors});const t=this._container.getBoundingClientRect();this._lineMaterial.useColor=1,this._lineMaterial.resolution.set(t.width,t.height),this._lineMesh=new y(this._lineGeometry,this._lineMaterial),this._lineMesh.computeLineDistances(),this._scene.add(this._lineMesh),this._linePickingMesh=this._lineMesh.clone(),this._linesPickingGeometry=new m,this._linesPickingGeometry.setPositions(e.positions),this._linesPickingGeometry.setColors(e.pickingColors),this._linesPickingGeometry.addAttribute("linewidth",new n.InstancedBufferAttribute(new Float32Array(e.sizes),1)),this._linesPickingGeometry.attributes.instanceStart.data.dynamic=!0,this._linesPickingGeometry.attributes.instanceEnd.data.dynamic=!0,this._linePickingMesh.geometry=this._linesPickingGeometry,this._pickingLineScene.add(this._linePickingMesh),this._pickingLineScene.updateMatrixWorld(!0)}_drawArrows(){this._arrowGeometry=new n.BufferGeometry;const{vertices:e,normals:t,colors:i}=this._calculateArrowData();this._arrowGeometry.addAttribute("position",new n.BufferAttribute(e,3).setDynamic(!0)),this._arrowGeometry.addAttribute("normal",new n.Float32BufferAttribute(t,3).setDynamic(!0)),this._arrowGeometry.addAttribute("color",new n.Float32BufferAttribute(i,3).setDynamic(!0)),this._arrowGeometry.computeBoundingSphere(),this._arrowMaterial=new n.MeshBasicMaterial({depthTest:!1,side:n.BackSide,vertexColors:n.VertexColors}),this._arrowMesh=new n.Mesh(this._arrowGeometry,this._arrowMaterial),this._scene.add(this._arrowMesh)}_drawLabels(){const e=new Float32Array(3*this._nodes.length),t=new Float32Array(this._nodes.length),i=new Float32Array(this._nodes.length);for(let n=0,s=0,r=this._nodes.length;n<r;n++,s+=3){if(e[s+0]=this._nodes[n].x+this._textCanvas.textureWidth/2,e[s+1]=this._nodes[n].y,e[s+2]=0,i[n]=this._nodes[n].size,this._nodes[n].label){const e=this._textCanvas.drawText(this._nodes[n].label,{color:"black",font:"Arial",fontSize:30});this._nodes[n]._labelIndex=e,t[n]=e}else t[n]=-1;this._nodes[n].__labelIndex=n}const s=new n.PlaneBufferGeometry(this._textCanvas.textureWidth,this._textCanvas.textureHeight);this._labelsGeometry=new n.InstancedBufferGeometry,this._labelsGeometry.index=s.index,this._labelsGeometry.attributes=s.attributes,this._labelsTranslateAttribute=new n.InstancedBufferAttribute(e,3),this._labelsGeometry.addAttribute("translation",this._labelsTranslateAttribute),this._labelsGeometry.addAttribute("size",new n.InstancedBufferAttribute(i,1)),this._labelsGeometry.addAttribute("image",new n.InstancedBufferAttribute(t,1)),this._labelsMaterial=new n.RawShaderMaterial({depthTest:!1,fragmentShader:h,transparent:!0,uniforms:{nodeScalingFactor:{type:"f",value:this.nodeScalingFactor},scale:{type:"f",value:this._controls?this._controls.scale:1},spriteDim:{value:new n.Vector2(this._textCanvas.textureWidth,this._textCanvas.textureHeight)},textureDim:{value:new n.Vector2(this._textCanvas.canvasWidth,this._textCanvas.canvasHeight)},textureMap:{type:"t",value:this._textCanvas.textureMap}},vertexShader:a}),this._labelsMesh=new n.Mesh(this._labelsGeometry,this._labelsMaterial),this._labelsMesh.frustumCulled=!1,this._scene.add(this._labelsMesh)}_setupScene(){this._scene=new n.Scene,this._scene.background=new n.Color(this.options.backgroundColor||"white")}_setupPickingScene(){this._pickingNodesScene=new n.Scene,this._pickingNodesScene.background=new n.Color(0),this._pickingLineScene=new n.Scene,this._pickingNodesScene.background=new n.Color(0)}_setupCamera(){const e=this._container.getBoundingClientRect();this._camera=new n.PerspectiveCamera(this._fov,e.width/e.height,.1,this._far),this._camera.lookAt(0,0,0)}_setupRenderer(){this._renderer=new n.WebGLRenderer({alpha:!0,antialias:!0}),this._renderer.setPixelRatio(window.devicePixelRatio);const e=this._container.getBoundingClientRect();this._renderer.setSize(e.width,e.height),this._container.appendChild(this._renderer.domElement)}_render(){console.log("Render draw calls: ",this._renderer.info.render.calls),this._renderer.render(this._scene,this._camera)}_constructLines(e){const t=[],i=[],s=[],r=[],o=new n.Color,a=new n.Color;return e.forEach((e,d)=>{const h=Math.atan2(e.target.y-e.source.y,e.target.x-e.source.x),c=e.source.x+e.source.size/2*this.nodeScalingFactor*Math.cos(h),l=e.source.y+e.source.size/2*this.nodeScalingFactor*Math.sin(h),_=e.target.x-(e.target.size/2*this.nodeScalingFactor+2*e.size)*Math.cos(h),u=e.target.y-(e.target.size/2*this.nodeScalingFactor+2*e.size)*Math.sin(h);if(o.setHex(e.color),a.setHex(d+1),e.source.x===e.target.x&&e.source.y===e.target.y){const d=new n.Vector3(e.source.x,e.source.y||0,0),h=new n.Vector3(e.target.x,e.target.y||0,0),c=15*e.source.size,l=-0,_=l+Math.PI/2,u=new n.CubicBezierCurve3(d,new n.Vector3(c*Math.cos(_),c*Math.sin(_),0).add(d),new n.Vector3(c*Math.cos(l),c*Math.sin(l),0).add(d),h).getPoints(50);let m;e._lineSizeRange=[s.length,s.length+2*u.length];for(let n=0;n<u.length-1;n+=2)m?(t.push(m.x,m.y,0,u[n].x,u[n].y,0,u[n].x,u[n].y,0,u[n+1].x,u[n+1].y,0),s.push(e.size,e.size),i.push(o.r,o.g,o.b,o.r,o.g,o.b,o.r,o.g,o.b,o.r,o.g,o.b),r.push(a.r,a.g,a.b,a.r,a.g,a.b,a.r,a.g,a.b,a.r,a.g,a.b)):(t.push(u[n].x,u[n].y,0,u[n+1].x,u[n+1].y,0),s.push(e.size),i.push(o.r,o.g,o.b,o.r,o.g,o.b),r.push(a.r,a.g,a.b,a.r,a.g,a.b)),m=u[n+1]}else t.push(c,l,0,_,u,0),e._lineSizeRange=[s.length,s.length+1],s.push(e.size),i.push(o.r,o.g,o.b,o.r,o.g,o.b),r.push(a.r,a.g,a.b,a.r,a.g,a.b)}),{colors:i,pickingColors:r,positions:t,sizes:s}}_calculateArrowVertices(e,t,i){const n=i.size/2*this.nodeScalingFactor-.4,s=t.x-i.x,r=t.y-i.y,o=Math.atan2(r,s),a=Math.sqrt(s*s+r*r),d=i.x+n*Math.cos(o),h=i.y+n*Math.sin(o),c=e.size,l=[d+2*e.size*s/a,h+2*e.size*r/a];return{pointAbove:[l[0]+c*-r/a,l[1]+c*s/a],pointBelow:[l[0]-c*-r/a,l[1]-c*s/a],pointOnLine:[d,h]}}_calculateNormals(e){const t=new n.Vector3,i=new n.Vector3,s=new n.Vector3,r=new n.Vector3,o=new n.Vector3;return t.set(e.pointBelow[0],e.pointBelow[1],0),i.set(e.pointAbove[0],e.pointAbove[1],0),s.set(e.pointOnLine[0],e.pointOnLine[1],0),r.subVectors(s,i),o.subVectors(t,i),r.cross(o),r.normalize(),{nx:r.x,ny:r.y,nz:r.z}}_calculateArrowData(){const e=new Float32Array(9*this._edges.length),t=new Float32Array(9*this._edges.length),i=new Float32Array(9*this._edges.length),s=new n.Color;for(let n=0,r=0,o=this._edges.length;n<o;n++,r+=9){if(s.setHex(this._edges[n].color),this._edges[n].target.id===this._edges[n].source.id)continue;const o=this._calculateArrowVertices(this._edges[n],this._edges[n].source,this._edges[n].target);e[r+0]=o.pointBelow[0]||0,e[r+1]=o.pointBelow[1]||0,e[r+2]=0,e[r+3]=o.pointOnLine[0]||0,e[r+4]=o.pointOnLine[1]||0,e[r+5]=0,e[r+6]=o.pointAbove[0]||0,e[r+7]=o.pointAbove[1]||0,e[r+8]=0;const a=this._calculateNormals(o);t[r+0]=a.nx,t[r+1]=a.ny,t[r+2]=a.nz,t[r+3]=a.nx,t[r+4]=a.ny,t[r+5]=a.nz,t[r+6]=a.nx,t[r+7]=a.ny,t[r+8]=a.nz,i[r+0]=s.r,i[r+1]=s.g,i[r+2]=s.b,i[r+3]=s.r,i[r+4]=s.g,i[r+5]=s.b,i[r+6]=s.r,i[r+7]=s.g,i[r+8]=s.b}return{colors:i,normals:t,vertices:e}}_indexingNodes(){this._indexedNodes={},this._nodes.forEach(e=>{this._indexedNodes[e.id]&&console.error(`Node with id ${e.id} already exists`),this._indexedNodes[e.id]=e})}_moveNodes(e=!1){const t=new Float32Array(3*this._nodes.length);for(let e=0,i=0,n=this._nodes.length;e<n;e++,i+=3)t[i+0]=this._nodes[e].x,t[i+1]=this._nodes[e].y,t[i+2]=0,this._nodes[e].__positionIndex=e;this._nodesGeometry.attributes.translation.setArray(t),this._nodesGeometry.attributes.translation.needsUpdate=!0,this._lineGeometry.dispose();const i=this._constructLines(this._edges);this._lineGeometry=new m,this._lineGeometry.setPositions(i.positions),this._lineGeometry.setColors(i.colors),this._lineGeometry.addAttribute("linewidth",new n.InstancedBufferAttribute(new Float32Array(i.sizes),1)),this._lineGeometry.attributes.instanceStart.data.dynamic=!0,this._lineGeometry.attributes.instanceEnd.data.dynamic=!0,this._lineMesh.geometry=this._lineGeometry;const{vertices:s,normals:r}=this._calculateArrowData();this._arrowGeometry.attributes.position.array=s,this._arrowGeometry.attributes.normal.array=r,this._arrowGeometry.attributes.position.needsUpdate=!0,this._arrowGeometry.attributes.normal.needsUpdate=!0,e&&(this._nodesPickingGeometry.attributes.translation.setArray(t),this._nodesPickingGeometry.attributes.translation.needsUpdate=!0,this._linesPickingGeometry.dispose(),this._linesPickingGeometry=new m,this._linesPickingGeometry.setPositions(i.positions),this._linesPickingGeometry.setColors(i.pickingColors),this._linesPickingGeometry.addAttribute("linewidth",new n.InstancedBufferAttribute(new Float32Array(i.sizes),1)),this._linesPickingGeometry.attributes.instanceStart.data.dynamic=!0,this._linesPickingGeometry.attributes.instanceEnd.data.dynamic=!0,this._linePickingMesh.geometry=this._linesPickingGeometry)}_getRandomFromRange(e,t){return Math.floor(Math.random()*(t-e))+e}_animate(){const e=Date.now(),t=()=>{let i=(Date.now()-e)/1e3;if(i>=1){for(const e in this._indexedNodes)this._indexedNodes[e]&&(this._indexedNodes[e].x=this._indexedNodes[e].toX,this._indexedNodes[e].y=this._indexedNodes[e].toY);this._moveNodes(!0),this._render()}else{i=(e=>{let t=e;return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)})(i);for(const e in this._indexedNodes)this._indexedNodes[e]&&(this._indexedNodes[e].x=this._indexedNodes[e].toX*i+this._indexedNodes[e].fromX*(1-i),this._indexedNodes[e].y=this._indexedNodes[e].toY*i+this._indexedNodes[e].fromY*(1-i));this._moveNodes(),this._render(),requestAnimationFrame(t)}};t()}}i.d(t,"PretyGraph",function(){return b})}])});